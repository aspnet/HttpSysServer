<#@ template language="C#" #>
<#@ assembly name="System.Core.dll" #>
<#@ import namespace="System.Linq" #>
<#
var props = new[]
{
	new { Key = "Accept", Name = "Accept", ID = "HttpSysRequestHeader.Accept" },
	new { Key = "Accept-Charset", Name = "AcceptCharset", ID = "HttpSysRequestHeader.AcceptCharset" },
	new { Key = "Accept-Encoding", Name = "AcceptEncoding", ID = "HttpSysRequestHeader.AcceptEncoding" },
	new { Key = "Accept-Language", Name = "AcceptLanguage", ID = "HttpSysRequestHeader.AcceptLanguage" },
	new { Key = "Allow", Name = "Allow", ID = "HttpSysRequestHeader.Allow" },
	new { Key = "Authorization", Name = "Authorization", ID = "HttpSysRequestHeader.Authorization" },
	new { Key = "Cache-Control", Name = "CacheControl", ID = "HttpSysRequestHeader.CacheControl" },
	new { Key = "Connection", Name = "Connection", ID = "HttpSysRequestHeader.Connection" },
	new { Key = "Content-Encoding", Name = "ContentEncoding", ID = "HttpSysRequestHeader.ContentEncoding" },
	new { Key = "Content-Language", Name = "ContentLanguage", ID = "HttpSysRequestHeader.ContentLanguage" },
	new { Key = "Content-Length", Name = "ContentLength", ID = "HttpSysRequestHeader.ContentLength" },
	new { Key = "Content-Location", Name = "ContentLocation", ID = "HttpSysRequestHeader.ContentLocation" },
	new { Key = "Content-Md5", Name = "ContentMd5", ID = "HttpSysRequestHeader.ContentMd5" },
	new { Key = "Content-Range", Name = "ContentRange", ID = "HttpSysRequestHeader.ContentRange" },
	new { Key = "Content-Type", Name = "ContentType", ID = "HttpSysRequestHeader.ContentType" },
	new { Key = "Cookie", Name = "Cookie", ID = "HttpSysRequestHeader.Cookie" },
	new { Key = "Date", Name = "Date", ID = "HttpSysRequestHeader.Date" },
	new { Key = "Expect", Name = "Expect", ID = "HttpSysRequestHeader.Expect" },
	new { Key = "Expires", Name = "Expires", ID = "HttpSysRequestHeader.Expires" },
	new { Key = "From", Name = "From", ID = "HttpSysRequestHeader.From" },
	new { Key = "Host", Name = "Host", ID = "HttpSysRequestHeader.Host" },
	new { Key = "If-Match", Name = "IfMatch", ID = "HttpSysRequestHeader.IfMatch" },
	new { Key = "If-Modified-Since", Name = "IfModifiedSince", ID = "HttpSysRequestHeader.IfModifiedSince" },
	new { Key = "If-None-Match", Name = "IfNoneMatch", ID = "HttpSysRequestHeader.IfNoneMatch" },
	new { Key = "If-Range", Name = "IfRange", ID = "HttpSysRequestHeader.IfRange" },
	new { Key = "If-Unmodified-Since", Name = "IfUnmodifiedSince", ID = "HttpSysRequestHeader.IfUnmodifiedSince" },
	new { Key = "Keep-Alive", Name = "KeepAlive", ID = "HttpSysRequestHeader.KeepAlive" },
	new { Key = "Last-Modified", Name = "LastModified", ID = "HttpSysRequestHeader.LastModified" },
	new { Key = "Max-Forwards", Name = "MaxForwards", ID = "HttpSysRequestHeader.MaxForwards" },
	new { Key = "Pragma", Name = "Pragma", ID = "HttpSysRequestHeader.Pragma" },
	new { Key = "Proxy-Authorization", Name = "ProxyAuthorization", ID = "HttpSysRequestHeader.ProxyAuthorization" },
	new { Key = "Range", Name = "Range", ID = "HttpSysRequestHeader.Range" },
	new { Key = "Referer", Name = "Referer", ID = "HttpSysRequestHeader.Referer" },
	new { Key = "Te", Name = "Te", ID = "HttpSysRequestHeader.Te" },
	new { Key = "Trailer", Name = "Trailer", ID = "HttpSysRequestHeader.Trailer" },
	new { Key = "Transfer-Encoding", Name = "TransferEncoding", ID = "HttpSysRequestHeader.TransferEncoding" },
	new { Key = "Translate", Name = "Translate", ID = "HttpSysRequestHeader.Translate" },
	new { Key = "Upgrade", Name = "Upgrade", ID = "HttpSysRequestHeader.Upgrade" },
	new { Key = "User-Agent", Name = "UserAgent", ID = "HttpSysRequestHeader.UserAgent" },
	new { Key = "Via", Name = "Via", ID = "HttpSysRequestHeader.Via" },
	new { Key = "Warning", Name = "Warning", ID = "HttpSysRequestHeader.Warning" },
}.Select((prop, Index)=>new {prop.Key, prop.Name, prop.ID, Index});

var lengths = props.GroupBy(prop=>prop.Key.Length).OrderBy(prop=>prop.Key);


Func<int,string> IsRead = Index => "((_flag" + (Index / 32) + " & 0x" + (1<<(Index % 32)).ToString("x") + "u) != 0)";
Func<int,string> MarkRead = Index => "_flag" + (Index / 32) + " |= 0x" + (1<<(Index % 32)).ToString("x") + "u";
Func<int,string> Clear = Index => "_flag" + (Index / 32) + " &= ~0x" + (1<<(Index % 32)).ToString("x") + "u";
#>
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// <auto-generated />

using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Primitives;

namespace Microsoft.AspNetCore.Server.HttpSys
{
    [GeneratedCode("TextTemplatingFileGenerator", "")]
    internal partial class RequestHeaders
    {
	    // Tracks if individual fields have been read from native or set directly.
		// Once read or set, their presence in the collection is marked by if their StringValues is null or not.
        private UInt32 _flag0, _flag1;

<# foreach(var prop in props) { #>
        private StringValues _<#=prop.Name#>;
<# } #>

<# foreach(var prop in props) { #>
        internal StringValues <#=prop.Name#>
        {
            get
			{
			    if (!<#=IsRead(prop.Index)#>)
				{
					string nativeValue = GetKnownHeader(<#=prop.ID#>);
					if (nativeValue != null)
					{
						_<#=prop.Name#> = nativeValue;
					}
                    <#=MarkRead(prop.Index)#>;
				}
			    return _<#=prop.Name#>;
		    }
            set 
            {
                <#=MarkRead(prop.Index)#>;
                _<#=prop.Name#> = value;
            }
        }

<# } #>
        private bool PropertiesContainsKey(string key)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (string.Equals(key, "<#=prop.Key#>", StringComparison.OrdinalIgnoreCase)) 
                    {
                        return <#=prop.Name#>.Count > 0;
                    }
<# } #>
                   break;
<# } #>
            }
            return false;
        }

        private bool PropertiesTryGetValue(string key, out StringValues value)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (string.Equals(key, "<#=prop.Key#>", StringComparison.OrdinalIgnoreCase))
                    {
					    value = <#=prop.Name#>;
						return value.Count > 0;
                    }
<# } #>
                   break;
<# } #>
            }
            value = StringValues.Empty;
            return false;
        }

        private bool PropertiesTrySetValue(string key, StringValues value)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (string.Equals(key, "<#=prop.Key#>", StringComparison.OrdinalIgnoreCase)) 
                    {
                        <#=MarkRead(prop.Index)#>;
                        <#=prop.Name#> = value;
                        return true;
                    }
<# } #>
                   break;
<# } #>
            }
            return false;
        }

        private bool PropertiesTryRemove(string key)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (_<#=prop.Name#>.Count > 0 
                        && string.Equals(key, "<#=prop.Key#>", StringComparison.Ordinal))
                    {
					    bool wasSet = <#=IsRead(prop.Index)#>;
                        <#=prop.Name#> = StringValues.Empty;
                        return wasSet;
                    }
<# } #>
                   break;
<# } #>
            }
            return false;
        }

        private IEnumerable<string> PropertiesKeys()
        {
<# foreach(var prop in props) { #>
            if (<#=prop.Name#>.Count > 0)
            {
                yield return "<#=prop.Key#>";
            }
<# } #>
        }

        private IEnumerable<StringValues> PropertiesValues()
        {
<# foreach(var prop in props) { #>
            if (<#=prop.Name#>.Count > 0)
            {
                yield return <#=prop.Name#>;
            }
<# } #>
        }

        private IEnumerable<KeyValuePair<string, StringValues>> PropertiesEnumerable()
        {
<# foreach(var prop in props) { #>
            if (<#=prop.Name#>.Count > 0)
            {
                yield return new KeyValuePair<string, StringValues>("<#=prop.Key#>", <#=prop.Name#>);
            }
<# } #>
        }
    }
}
