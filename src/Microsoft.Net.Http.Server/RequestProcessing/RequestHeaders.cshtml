// Copyright (c) Microsoft Open Technologies, Inc.
// All Rights Reserved
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
// WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF
// TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR
// NON-INFRINGEMENT.
// See the Apache 2 License for the specific language governing
// permissions and limitations under the License.
// <auto-generated />

using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

@using System
@using System.Linq

@{
var props = new[]
{
    new { Key = "Accept", Name = "Accept", ID = "HttpSysRequestHeader.Accept" },
    new { Key = "Accept-Charset", Name = "AcceptCharset", ID = "HttpSysRequestHeader.AcceptCharset" },
    new { Key = "Accept-Encoding", Name = "AcceptEncoding", ID = "HttpSysRequestHeader.AcceptEncoding" },
    new { Key = "Accept-Language", Name = "AcceptLanguage", ID = "HttpSysRequestHeader.AcceptLanguage" },
    new { Key = "Allow", Name = "Allow", ID = "HttpSysRequestHeader.Allow" },
    new { Key = "Authorization", Name = "Authorization", ID = "HttpSysRequestHeader.Authorization" },
    new { Key = "Cache-Control", Name = "CacheControl", ID = "HttpSysRequestHeader.CacheControl" },
    new { Key = "Connection", Name = "Connection", ID = "HttpSysRequestHeader.Connection" },
    new { Key = "Content-Encoding", Name = "ContentEncoding", ID = "HttpSysRequestHeader.ContentEncoding" },
    new { Key = "Content-Language", Name = "ContentLanguage", ID = "HttpSysRequestHeader.ContentLanguage" },
    new { Key = "Content-Length", Name = "ContentLength", ID = "HttpSysRequestHeader.ContentLength" },
    new { Key = "Content-Location", Name = "ContentLocation", ID = "HttpSysRequestHeader.ContentLocation" },
    new { Key = "Content-Md5", Name = "ContentMd5", ID = "HttpSysRequestHeader.ContentMd5" },
    new { Key = "Content-Range", Name = "ContentRange", ID = "HttpSysRequestHeader.ContentRange" },
    new { Key = "Content-Type", Name = "ContentType", ID = "HttpSysRequestHeader.ContentType" },
    new { Key = "Cookie", Name = "Cookie", ID = "HttpSysRequestHeader.Cookie" },
    new { Key = "Date", Name = "Date", ID = "HttpSysRequestHeader.Date" },
    new { Key = "Expect", Name = "Expect", ID = "HttpSysRequestHeader.Expect" },
    new { Key = "Expires", Name = "Expires", ID = "HttpSysRequestHeader.Expires" },
    new { Key = "From", Name = "From", ID = "HttpSysRequestHeader.From" },
    new { Key = "Host", Name = "Host", ID = "HttpSysRequestHeader.Host" },
    new { Key = "If-Match", Name = "IfMatch", ID = "HttpSysRequestHeader.IfMatch" },
    new { Key = "If-Modified-Since", Name = "IfModifiedSince", ID = "HttpSysRequestHeader.IfModifiedSince" },
    new { Key = "If-None-Match", Name = "IfNoneMatch", ID = "HttpSysRequestHeader.IfNoneMatch" },
    new { Key = "If-Range", Name = "IfRange", ID = "HttpSysRequestHeader.IfRange" },
    new { Key = "If-Unmodified-Since", Name = "IfUnmodifiedSince", ID = "HttpSysRequestHeader.IfUnmodifiedSince" },
    new { Key = "Keep-Alive", Name = "KeepAlive", ID = "HttpSysRequestHeader.KeepAlive" },
    new { Key = "Last-Modified", Name = "LastModified", ID = "HttpSysRequestHeader.LastModified" },
    new { Key = "Max-Forwards", Name = "MaxForwards", ID = "HttpSysRequestHeader.MaxForwards" },
    new { Key = "Pragma", Name = "Pragma", ID = "HttpSysRequestHeader.Pragma" },
    new { Key = "Proxy-Authorization", Name = "ProxyAuthorization", ID = "HttpSysRequestHeader.ProxyAuthorization" },
    new { Key = "Range", Name = "Range", ID = "HttpSysRequestHeader.Range" },
    new { Key = "Referer", Name = "Referer", ID = "HttpSysRequestHeader.Referer" },
    new { Key = "Te", Name = "Te", ID = "HttpSysRequestHeader.Te" },
    new { Key = "Trailer", Name = "Trailer", ID = "HttpSysRequestHeader.Trailer" },
    new { Key = "Transfer-Encoding", Name = "TransferEncoding", ID = "HttpSysRequestHeader.TransferEncoding" },
    new { Key = "Translate", Name = "Translate", ID = "HttpSysRequestHeader.Translate" },
    new { Key = "Upgrade", Name = "Upgrade", ID = "HttpSysRequestHeader.Upgrade" },
    new { Key = "User-Agent", Name = "UserAgent", ID = "HttpSysRequestHeader.UserAgent" },
    new { Key = "Via", Name = "Via", ID = "HttpSysRequestHeader.Via" },
    new { Key = "Warning", Name = "Warning", ID = "HttpSysRequestHeader.Warning" },
}.Select((prop, Index)=>new {prop.Key, prop.Name, prop.ID, Index});

var lengths = props.GroupBy(prop=>prop.Key.Length).OrderBy(prop=>prop.Key);
}

@functions {
string IsRead(int index)
{
    return "((_flag" + (index / 32) + " & 0x" + (1<<(index % 32)).ToString("x") + "u) != 0)";
}

string MarkRead(int index)
{
    return "_flag" + (index / 32) + " |= 0x" + (1<<(index % 32)).ToString("x") + "u";
}

string Clear(int index)
{
    return "_flag" + (index / 32) + " &= ~0x" + (1<<(index % 32)).ToString("x") + "u";
}
}

namespace Microsoft.Net.Http.Server
{
    [GeneratedCode("TextTemplatingFileGenerator", "")]
    internal partial class RequestHeaders
    {
        // Tracks if individual fields have been read from native or set directly.
        // Once read or set, their presence in the collection is marked by if their string[] is null or not.
        private UInt32 _flag0, _flag1;

@foreach(var prop in props) {
        @:private string[] _@(prop.Name);
}

@foreach(var prop in props) {
        @:internal string[] @prop.Name
        @:{
            @:get
            @:{
                @:Populate@(prop.Name)();
                @:return _@(prop.Name);
            @:}
            @:set
            @:{
                @:@MarkRead(prop.Index);
                @:_@(prop.Name) = value;
            @:}
        @:}
}

@foreach(var prop in props) {
        @:private void Populate@(prop.Name)()
        @:{
            @:if (!(@(IsRead(prop.Index))))
            @:{
                @:string nativeValue = GetKnownHeader(@prop.ID);
                @:if (nativeValue != null)
                @:{
                    @:_@(prop.Name) = new string[] { nativeValue };
                @:}
                @:@MarkRead(prop.Index);
            @:}
        @:}
@:
}

        private void PopulateAllKnownHeaders()
        {
@foreach(var prop in props) {
            @:Populate@(prop.Name)();
}
        }

        private bool PropertiesContainsKey(string key)
        {
            switch (key.Length)
            {
@foreach(var length in lengths) {
                @:case @(length.Key):
    foreach(var prop in length) {
                    @:if (string.Equals(key, "@(prop.Key)", StringComparison.OrdinalIgnoreCase))
                    @:{
                        @:return @(prop.Name) != null;
                    @:}
    }
                    @:break;
}
            }
            return false;
        }

        private bool PropertiesTryGetValue(string key, out string[] value)
        {
            switch (key.Length)
            {
@foreach(var length in lengths) {
                @:case @(length.Key):
    foreach(var prop in length) {
                    @:if (string.Equals(key, "@(prop.Key)", StringComparison.OrdinalIgnoreCase))
                    @:{
                        @:value = @(prop.Name);
                        @:return value != null;
                    @:}
    }
                   @:break;
}
            }
            value = null;
            return false;
        }

        private bool PropertiesTrySetValue(string key, string[] value)
        {
            switch (key.Length)
            {
@foreach(var length in lengths) {
                @:case @(length.Key):
    foreach(var prop in length) {
                    @:if (string.Equals(key, "@(prop.Key)", StringComparison.OrdinalIgnoreCase))
                    @:{
                        @:@(MarkRead(prop.Index));
                        @:@(prop.Name) = value;
                        @:return true;
                    @:}
    }
                   @:break;
}
            }
            return false;
        }

        private bool PropertiesTryRemove(string key)
        {
            switch (key.Length)
            {
@foreach(var length in lengths) {
                @:case @(length.Key):
    foreach(var prop in length) {
                    @:if (_@(prop.Name) != null && string.Equals(key, "@(prop.Key)", StringComparison.Ordinal))
                    @:{
                        @:bool wasSet = @(IsRead(prop.Index));
                        @:@(prop.Name) = null;
                        @:return wasSet;
                    @:}
    }
                    @:break;
}
            }
            return false;
        }

        private IEnumerable<string> PropertiesKeys()
        {
@foreach(var prop in props) {
            @:if (@(prop.Name) != null)
            @:{
                @:yield return "@(prop.Key)";
            @:}
}
        }

        private IEnumerable<string[]> PropertiesValues()
        {
@foreach(var prop in props) {
            @:if (@(prop.Name) != null)
            @:{
                @:yield return @(prop.Name);
            @:}
}
        }

        private IEnumerable<KeyValuePair<string, string[]>> PropertiesEnumerable()
        {
@foreach(var prop in props) {
            @:if (@(prop.Name) != null)
            @:{
                @:yield return new KeyValuePair<string, string[]>("@(prop.Key)", @(prop.Name));
            @:}
}
        }
    }
}
